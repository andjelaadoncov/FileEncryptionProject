@page "/encryption"

@using System.IO
@using CryptographyWebApp.Services
@using System.Security.Cryptography
@inject CryptoService CryptoService

<div class="encryption-page">
    <div class="left-section">
        <!-- Manual Encryption Section -->
        <div class="encryption-container">
            <h3>Manual File Encryption/Decryption</h3>

            <div class="form-group">
                <label for="fileInput">Select a file:</label>
                <InputFile OnChange="HandleFileSelection" />
            </div>

            <div class="form-group">
                <label for="algorithm">Select an algorithm:</label>
                <select @bind="SelectedAlgorithm" class="dropdown">
                    <option value="Bifid">Bifid</option>
                    <option value="RC6">RC6</option>
                    <option value="RC6 OFB">RC6 OFB</option>
                </select>
            </div>

            <div class="button-group">
                <button class="primary-button" @onclick="EncryptFile">Encrypt</button>
                <button class="primary-button" @onclick="DecryptFile">Decrypt</button>
            </div>
        </div>

        <hr />

        <!-- Automatic Encryption Section -->
        <div class="encryption-container">
            <h3>Automatic File Encryption (File System Watcher)</h3>

            <div class="fsw-settings">
                <label>File System Watcher:</label>
                <button class="action-button" @onclick="ToggleFileWatcher">@FileWatcherStatus</button>
            </div>

            <div class="form-group">
                <label for="algorithm">Select an algorithm:</label>
                <select @bind="SelectedAlgorithm" class="dropdown">
                    <option value="Bifid">Bifid</option>
                    <option value="RC6">RC6</option>
                    <option value="RC6 OFB">RC6 OFB</option>
                </select>
            </div>

            <div class="form-group">
                <label for="outputFolder">Output Folder:</label>
                <input type="text" @bind="OutputFolder" placeholder="Enter output folder path" class="input-field" />
            </div>

        </div>
    </div>

    <div class="right-section">
        <div class="encryption-container">
            <div class="file-table-container">
                <h4>Target Directory Files</h4>
                <table class="file-table">
                    <thead>
                        <tr>
                            <th>File Name</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var file in TargetFiles)
                        {
                            <tr>
                                <td>@file</td>
                            </tr>
                        }
                    </tbody>
                </table>

                <h4>X Directory Files</h4>
                <table class="file-table">
                    <thead>
                        <tr>
                            <th>File Name</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var file in XFiles)
                        {
                            <tr>
                                <td>@file</td>
                                <td>
                                    <button class="action-button" @onclick="() => DecryptFileFromList(file)">Decrypt</button>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<!-- Result Message -->
<div class="message-box">
    @if (!string.IsNullOrEmpty(ResultMessage))
    {
        <p class="@ResultMessageClass">@ResultMessage</p>
    }
</div>

@code {
    private string _selectedAlgorithm = "Bifid";
    private string SelectedAlgorithm
    {
        get => _selectedAlgorithm;
        set
        {
            _selectedAlgorithm = value;
            DirectoryWatcherService.Update(SharedKey, _selectedAlgorithm); // Automatsko ažuriranje servisa
        }
    }

    private string FilePath;
    private string ResultMessage;
    private byte[] SharedKey;
    private string OutputFolder;
    private bool IsFileWatcherEnabled = false;
    private string FileWatcherStatus => IsFileWatcherEnabled ? "Stop Watching" : "Start Watching";

    private List<string> TargetFiles = new();
    private List<string> XFiles = new();

    [Inject] private DirectoryWatcherService DirectoryWatcherService { get; set; }

    private void ToggleFileWatcher()
    {
        if (IsFileWatcherEnabled)
        {
            DirectoryWatcherService.StopWatching();
            IsFileWatcherEnabled = false;
        }
        else
        {
            DirectoryWatcherService.Update(SharedKey, SelectedAlgorithm); // Ažuriranje pre aktiviranja praćenja
            DirectoryWatcherService.StartWatching();
            IsFileWatcherEnabled = true;
        }
    }


    protected override void OnInitialized()
    {
        SharedKey = GenerateDiffieHellmanKey();
        RefreshFileLists();

        EncryptExistingFiles(); // Automatski enkriptuje postojeće fajlove

        DirectoryWatcherService.FilesChanged += OnFilesChanged;
    }

    private void EncryptExistingFiles()
    {
        try
        {
            Console.WriteLine("OVDE JE OVAJ ALGO ----> 2 incriptovanje: " + SelectedAlgorithm);
            DirectoryWatcherService.Update(SharedKey, SelectedAlgorithm);
            foreach (var file in Directory.GetFiles(DirectoryWatcherService.TargetDirectory))
            {
                byte[] fileData = File.ReadAllBytes(file);
                byte[] encryptedData = CryptoService.EncryptFile(fileData, SelectedAlgorithm, SharedKey);

                string outputFilePath = Path.Combine(DirectoryWatcherService.OutputDirectory, Path.GetFileNameWithoutExtension(file) + ".dat");
                File.WriteAllBytes(outputFilePath, encryptedData);
            }

            RefreshFileLists();
        }
        catch (Exception ex)
        {
            ResultMessage = $"Error encrypting existing files: {ex.Message}";
        }
    }


    private void OnFilesChanged()
    {
        InvokeAsync(() =>
        {
            RefreshFileLists();
            StateHasChanged();
        });
    }

    public void Dispose()
    {
        DirectoryWatcherService.FilesChanged -= OnFilesChanged;
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            var tempPath = Path.Combine(Path.GetTempPath(), file.Name);

            using var stream = file.OpenReadStream();
            using var fileStream = File.Create(tempPath);
            await stream.CopyToAsync(fileStream);

            FilePath = tempPath;
            ResultMessage = $"File selected: {file.Name}";
        }
        catch (Exception ex)
        {
            ResultMessage = $"Error selecting file: {ex.Message}";
        }
    }

    private async Task EncryptFile()
    {
        if (string.IsNullOrEmpty(FilePath))
        {
            ResultMessage = "Please select a file.";
            return;
        }

        if (string.IsNullOrEmpty(OutputFolder) || !Directory.Exists(OutputFolder))
        {
            ResultMessage = "Please specify a valid output folder.";
            return;
        }

        try
        {
            byte[] fileData = File.ReadAllBytes(FilePath);
            byte[] encryptedData = CryptoService.EncryptFile(fileData, SelectedAlgorithm, SharedKey);

            string encryptedPath = Path.Combine(OutputFolder, "encrypted.dat");
            await File.WriteAllBytesAsync(encryptedPath, encryptedData);

            ResultMessage = $"File successfully encrypted and saved at {encryptedPath}.";
            RefreshFileLists();
        }
        catch (Exception ex)
        {
            ResultMessage = $"Error during encryption: {ex.Message}";
        }
    }

    private async Task DecryptFile()
    {
        if (string.IsNullOrEmpty(FilePath))
        {
            ResultMessage = "Please select a file.";
            return;
        }

        if (string.IsNullOrEmpty(OutputFolder) || !Directory.Exists(OutputFolder))
        {
            ResultMessage = "Please specify a valid output folder.";
            return;
        }

        try
        {
            byte[] encryptedData = File.ReadAllBytes(FilePath);

            if (encryptedData.Length == 0)
            {
                ResultMessage = "The selected file is empty.";
                return;
            }

            byte[] decryptedData = CryptoService.DecryptFile(encryptedData, SelectedAlgorithm, SharedKey);

            string decryptedPath = Path.Combine(OutputFolder, $"decrypted{Path.GetExtension(FilePath)}");
            await File.WriteAllBytesAsync(decryptedPath, decryptedData);

            ResultMessage = $"File successfully decrypted and saved at {decryptedPath}.";
            RefreshFileLists();
        }
        catch (Exception ex)
        {
            ResultMessage = $"Error during decryption: {ex.Message}";
        }
    }

    private async Task DecryptFileFromList(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(DirectoryWatcherService.OutputDirectory, filePath);
            Console.WriteLine($"Attempting to decrypt file: {fullPath}");

            if (!File.Exists(fullPath))
            {
                ResultMessage = $"File {filePath} does not exist.";
                return;
            }

            byte[] encryptedData = File.ReadAllBytes(fullPath);
            Console.WriteLine($"Read encrypted data length: {encryptedData.Length}");

            if (encryptedData.Length == 0)
            {
                ResultMessage = $"File {filePath} is empty.";
                return;
            }

            // Proveri ključ
            if (SharedKey == null || SharedKey.Length == 0)
            {
                ResultMessage = "SharedKey is not initialized.";
                return;
            }

            byte[] decryptedData = CryptoService.DecryptFile(encryptedData, SelectedAlgorithm, SharedKey);
            Console.WriteLine($"Decryption successful, decrypted data length: {decryptedData.Length}");

            string decryptedPath = Path.Combine(OutputFolder, $"decrypted_{filePath}");
            await File.WriteAllBytesAsync(decryptedPath, decryptedData);

            ResultMessage = $"File {filePath} successfully decrypted to {decryptedPath}.";
            RefreshFileLists();
        }
        catch (CryptographicException cryptoEx)
        {
            Console.WriteLine($"Cryptographic error: {cryptoEx.Message}");
            ResultMessage = $"Decryption failed: {cryptoEx.Message}. Please ensure the correct key and algorithm are used.";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"General error in DecryptFileFromList: {ex.Message}");
            ResultMessage = $"Error decrypting file {filePath}: {ex.Message}";
        }
    }



    private void RefreshFileLists()
    {
        TargetFiles = Directory.Exists(DirectoryWatcherService.TargetDirectory)
            ? Directory.GetFiles(DirectoryWatcherService.TargetDirectory).Select(Path.GetFileName).ToList()
            : new List<string>();

        XFiles = Directory.Exists(DirectoryWatcherService.OutputDirectory)
            ? Directory.GetFiles(DirectoryWatcherService.OutputDirectory).Select(Path.GetFileName).ToList()
            : new List<string>();
    }

    private byte[] GenerateDiffieHellmanKey()
    {
        using var diffieHellman = new ECDiffieHellmanCng
            {
                KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash,
                HashAlgorithm = CngAlgorithm.Sha256
            };

        byte[] publicKey = diffieHellman.PublicKey.ToByteArray();
        byte[] recipientPublicKey = publicKey;

        using var recipientKey = new ECDiffieHellmanCng(CngKey.Import(recipientPublicKey, CngKeyBlobFormat.EccPublicBlob));
        return diffieHellman.DeriveKeyMaterial(recipientKey.PublicKey);
    }

    private string ResultMessageClass => ResultMessage.Contains("successfully") ? "success-message" : "error-message";
}